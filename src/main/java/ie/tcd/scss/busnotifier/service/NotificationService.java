package ie.tcd.scss.busnotifier.service;

import ie.tcd.scss.busnotifier.domain.BrowserEndpoint;
import ie.tcd.scss.busnotifier.domain.DublinBusSubscription;
import ie.tcd.scss.busnotifier.domain.User;
import ie.tcd.scss.busnotifier.repo.BrowserEndpointRepo;
import ie.tcd.scss.busnotifier.repo.DublinBusSubscriptionRepo;
import ie.tcd.scss.busnotifier.schema.DeleteDublinBusSubscriptionsDTO;
import jakarta.annotation.PostConstruct;
import nl.martijndwars.webpush.Notification;
import nl.martijndwars.webpush.PushService;
import nl.martijndwars.webpush.Subscription;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.jose4j.lang.JoseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.Security;
import java.util.List;
import java.util.concurrent.ExecutionException;

@Service
public class NotificationService {

    private final Logger logger = LoggerFactory.getLogger(NotificationService.class);
    @Value("${vapid.public.key}")
    private String publicKey;
    @Value("${vapid.private.key}")
    private String privateKey;

    @Autowired
    private BrowserEndpointRepo browserEndpointRepo;


    @Autowired
    private DublinBusSubscriptionRepo dublinBusSubscriptionRepo;

    private PushService pushService;

    @PostConstruct
    private void postConstruct() throws GeneralSecurityException {
        Security.addProvider(new BouncyCastleProvider());
        pushService = new PushService(publicKey, privateKey);
    }

    // Send a notification to users every second
    @Scheduled(fixedRate = 60_000)
    private void push() {
        for (var sub : browserEndpointRepo.findAll()) {
            logger.info("Sending to to " +  sub.endpoint);
            try {
                var notification = new Notification(
                        sub.endpoint,
                        sub.userPublicKey,
                        sub.userAuth,
                        "\"TODO: USE DUBLIN BUS API LOGIC\""
                );
                pushService.send(notification);
            } catch (GeneralSecurityException | IOException | JoseException | ExecutionException |
                     InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * @param user The user who is adding the subscription
     * @param subscription The browser-generated subscription data structure (not used internally)
     */
     public void addBrowserEndpoint(User user, Subscription subscription) {
        var browserEndpoint = new BrowserEndpoint();
        browserEndpoint.endpoint = subscription.endpoint;
        browserEndpoint.userAuth = subscription.keys.auth;
        browserEndpoint.userPublicKey = subscription.keys.p256dh;
        browserEndpoint.user = user;
        browserEndpointRepo.save(browserEndpoint);
    }

    /**
     * Remove a browser endpoint entity from the database
     * @param endpoint The push vendor URL generated by the browser
     * @return true if an element was deleted, false otherwise
     */
    public boolean removeBrowserEndpoints(String endpoint) {
        // This is not thread safe (time of check vs. time of use problem) and requires
        // two database queries when it should only take one.
        if (browserEndpointRepo.existsById(endpoint)) {
            browserEndpointRepo.deleteById(endpoint);
            return true;
        } else {
            return false;
        }
    }

    /**
     * @return The VAPID public key for use in the browser
     */
    public String getPublicKey() {
        return publicKey;
    }

    public List<BrowserEndpoint> getBrowserEndpointsForUser(User user) {
        return browserEndpointRepo.findByUser(user).stream().toList();
    }

    public void addDublinBusSubscription(User user, String endpoint, String busStopIdentifier) {
        var browserEndpoint = browserEndpointRepo.findById(endpoint).orElseThrow();
        if (browserEndpoint.user.getId() != user.getId()) {
            return;
        }
        if (!dublinBusSubscriptionRepo.existsById(busStopIdentifier)) {
            var dublinBusSubscription = new DublinBusSubscription(user,  browserEndpoint, busStopIdentifier);
            dublinBusSubscriptionRepo.save(dublinBusSubscription);
        }
    }

    public List<DublinBusSubscription> getDublinBusSubscriptions(User user) {
        return dublinBusSubscriptionRepo.findByUser(user).stream().toList();
    }

    public void deleteDublinBusSubscriptions(User user, List<DeleteDublinBusSubscriptionsDTO.DublinBusSubscriptionDTO> toDelete) {
        for (var deletionCandidate : toDelete) {
            var endpoint = deletionCandidate.endpoint;
            var busStopIdentifier = deletionCandidate.busStopIdentifier;
            dublinBusSubscriptionRepo.deleteByUserIdAndBrowserEndpointEndpointAndBusStopId(user.getId(), endpoint, busStopIdentifier);
        }
    }
}
